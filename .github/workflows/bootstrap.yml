name: Bootstrap scaffold

permissions:
  contents: write

on:
  workflow_dispatch:

jobs:
  bootstrap:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Create scaffold files
        run: |
          set -euo pipefail
          # create directories
          mkdir -p .github/workflows apps/api/src apps/api/prisma apps/web/src/pages packages/shared

          # README.md
          cat > README.md <<'EOF'
# Real Estate Platform

Monorepo scaffold for the Real Estate Transaction Management Platform.

Structure:
- apps/web: Next.js (frontend placeholder)
- apps/api: Express + TypeScript + Prisma (backend)
- packages/shared: shared types/utilities

This initial commit includes a minimal scaffold, Prisma schema, example .env, and CI workflow.
See docs in the repository for setup steps.
EOF

          # .gitignore
          cat > .gitignore <<'EOF'
node_modules
.env
.env.local
/dist
/.next
/apps/api/node_modules
/apps/web/node_modules
/packages/*/node_modules
.DS_Store
EOF

          # .env.example
          cat > .env.example <<'EOF'
# Frontend
NEXT_PUBLIC_API_URL=http://localhost:4000/api/v1
NEXT_PUBLIC_AUTH0_DOMAIN=your-domain.auth0.com
NEXT_PUBLIC_AUTH0_CLIENT_ID=your-client-id
NEXT_PUBLIC_AUTH0_AUDIENCE=https://your-api.com

# Backend
PORT=4000
NODE_ENV=development
DATABASE_URL=postgresql://user:password@localhost:5432/realestate_db
JWT_SECRET=your-super-secret-key-change-in-production
JWT_EXPIRES_IN=15m
REFRESH_TOKEN_EXPIRES_IN=7d

# AWS S3
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
AWS_S3_BUCKET=your-bucket-name
AWS_REGION=us-east-1

# Providers (placeholders)
SENDGRID_API_KEY=your-sendgrid-key
TWILIO_API_KEY=your-twilio-key
DOCUSIGN_CLIENT_ID=your-docusign-client-id
DOCUSIGN_CLIENT_SECRET=your-docusign-client-secret
EOF

          # CI workflow placeholder
          cat > .github/workflows/ci.yml <<'EOF'
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Install backend deps
        run: |
          cd apps/api
          npm ci || true
      - name: Install frontend deps
        run: |
          cd apps/web
          npm ci || true
      - name: Lint
        run: echo "No linter configured yet"
      - name: Run tests
        run: echo "No tests configured yet"
EOF

          # apps/api/package.json
          cat > apps/api/package.json <<'EOF'
{
  "name": "real-estate-api",
  "version": "0.1.0",
  "private": true,
  "main": "dist/index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc -p .",
    "start": "node dist/index.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.400.0",
    "@aws-sdk/s3-request-presigner": "^3.400.0",
    "@prisma/client": "^5.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.0",
    "express": "^4.18.2",
    "helmet": "^6.0.1",
    "jsonwebtoken": "^9.0.0",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "prisma": "^5.0.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.17",
    "@types/node": "^20.0.0",
    "ts-node": "^10.9.1",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.0.0"
  }
}
EOF

          # apps/api/tsconfig.json
          cat > apps/api/tsconfig.json <<'EOF'
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true
  },
  "include": ["src", "prisma"]
}
EOF

          # apps/api/src/index.ts
          cat > apps/api/src/index.ts <<'EOF'
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import dotenv from 'dotenv';
import uploadRoutes from './routes/upload.routes';
import healthRouter from './routes/health.routes';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 4000;

app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(morgan('dev'));

// Mount routes
app.use('/api/v1/health', healthRouter);
app.use('/api/v1/uploads', uploadRoutes);

app.get('/', (_req, res) => res.send('Real Estate API: hello'));

app.use((err: any, _req: any, res: any, _next: any) => {
  console.error(err);
  res.status(500).json({
    error: 'Something went wrong',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

app.listen(PORT, () => {
  console.log(`ðŸš€ Server running on port ${PORT}`);
});
EOF

          # apps/api/src/routes/health.routes.ts
          cat > apps/api/src/routes/health.routes.ts <<'EOF'
import { Router } from 'express';
const router = Router();

router.get('/', (_req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

export default router;
EOF

          # apps/api/src/middleware/auth.middleware.ts
          cat > apps/api/src/middleware/auth.middleware.ts <<'EOF'
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

export interface AuthRequest extends Request {
  user?: any;
}

export const authenticateToken = (req: AuthRequest, res: Response, next: NextFunction) => {
  const authHeader = req.headers.authorization;
  const token = authHeader?.split(' ')[1];
  if (!token) return res.status(401).json({ error: 'Access token required' });
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'dev-secret');
    req.user = decoded;
    next();
  } catch (err) {
    return res.status(403).json({ error: 'Invalid or expired token' });
  }
};
EOF

          # apps/api/src/services/s3.service.ts
          cat > apps/api/src/services/s3.service.ts <<'EOF'
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import path from 'path';

const s3 = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || '',
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || ''
  }
});

export async function getPresignedUploadUrl(filename: string, contentType: string, maxAgeSeconds = 300) {
  const bucket = process.env.AWS_S3_BUCKET!;
  const key = `uploads/${Date.now()}-${path.basename(filename)}`;

  const command = new PutObjectCommand({
    Bucket: bucket,
    Key: key,
    ContentType: contentType
  });

  const url = await getSignedUrl(s3, command, { expiresIn: maxAgeSeconds });
  return { url, key };
}
EOF

          # apps/api/src/routes/upload.routes.ts
          cat > apps/api/src/routes/upload.routes.ts <<'EOF'
import { Router } from 'express';
import { getPresignedUploadUrl } from '../services/s3.service';
const router = Router();

/**
 * POST /api/v1/uploads/presign
 * Body: { filename, contentType }
 * Returns: { url, key } - client PUTs file to url (no auth example here; add authenticateToken middleware)
 */
router.post('/presign', async (req, res, next) => {
  try {
    const { filename, contentType } = req.body;
    if (!filename || !contentType) {
      return res.status(400).json({ error: 'filename and contentType required' });
    }

    const { url, key } = await getPresignedUploadUrl(filename, contentType);
    res.json({ url, key });
  } catch (err) {
    next(err);
  }
});

export default router;
EOF

          # apps/api/prisma/seed.ts
          cat > apps/api/prisma/seed.ts <<'EOF'
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();

async function main() {
  // Create a sample user (passwords are not stored here; use Auth0 for auth in production)
  const user = await prisma.user.upsert({
    where: { email: 'admin@example.com' },
    update: {},
    create: {
      email: 'admin@example.com',
      firstName: 'Admin',
      lastName: 'User',
      role: 'admin'
    }
  });

  console.log('Seeded user:', user.email);
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
EOF

          # apps/api/prisma/schema.prisma
          cat > apps/api/prisma/schema.prisma <<'EOF'
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String    @id @default(uuid())
  email           String    @unique
  passwordHash    String?
  firstName       String
  lastName        String
  phone           String?
  role            String    @default("agent")
  brokerageId     String?
  mfaEnabled      Boolean   @default(false)
  preferences     Json?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  clients         Client[]
  transactions    Transaction[]
  documents       Document[]
  appointments    Appointment[]
  messages        Message[]
  messageTemplates MessageTemplate[]
  @@map("users")
}

model Client {
  id              String    @id @default(uuid())
  userId          String
  type            String
  stage           String    @default("lead")
  status          String    @default("warm")
  leadScore       Int?      @default(0)
  source          String?
  firstName       String
  lastName        String
  email           String
  phone           String?
  preferences     Json?
  notes           String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  buyerTransactions  Transaction[] @relation("BuyerClient")
  sellerTransactions Transaction[] @relation("SellerClient")
  timeline        ClientTimeline[]
  appointments    Appointment[]
  documents       Document[]
  messages        Message[]
  @@map("clients")
}

model Transaction {
  id              String    @id @default(uuid())
  userId          String
  buyerClientId   String?
  sellerClientId  String?
  transactionType String
  status          String    @default("pending")
  propertyAddress Json
  listPrice       Decimal?
  finalPrice      Decimal?
  contractDate    DateTime?
  closingDate     DateTime?
  commissionEarned Decimal?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  buyerClient     Client?   @relation("BuyerClient", fields: [buyerClientId], references: [id])
  sellerClient    Client?   @relation("SellerClient", fields: [sellerClientId], references: [id])
  milestones      Milestone[]
  parties         TransactionParty[]
  timeline        TransactionTimeline[]
  documents       Document[]
  appointments    Appointment[]
  messages        Message[]
  @@map("transactions")
}

model Milestone {
  id              String    @id @default(uuid())
  transactionId   String
  milestoneType   String
  name            String
  dueDate         DateTime?
  completedDate   DateTime?
  status          String    @default("pending")
  responsibleParty String?
  createdAt       DateTime  @default(now())
  transaction     Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  @@map("milestones")
}

model TransactionParty {
  id              String    @id @default(uuid())
  transactionId   String
  partyType       String
  companyName     String?
  contactName     String
  email           String?
  phone           String?
  createdAt       DateTime  @default(now())
  transaction     Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  @@map("transaction_parties")
}

model Document {
  id              String    @id @default(uuid())
  userId          String
  transactionId   String?
  clientId        String?
  category        String
  documentType    String?
  filename        String
  storagePath     String
  fileSize        Int?
  aiProcessed     Boolean   @default(false)
  aiExtractedData Json?
  status          String    @default("active")
  createdAt       DateTime  @default(now())
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  transaction     Transaction? @relation(fields: [transactionId], references: [id])
  client          Client?   @relation(fields: [clientId], references: [id])
  @@map("documents")
}

model Appointment {
  id              String    @id @default(uuid())
  userId          String
  clientId        String?
  transactionId   String?
  appointmentType String
  title           String
  location        Json?
  startTime       DateTime
  endTime         DateTime
  status          String    @default("scheduled")
  notes           String?
  createdAt       DateTime  @default(now())
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  client          Client?   @relation(fields: [clientId], references: [id])
  transaction     Transaction? @relation(fields: [transactionId], references: [id])
  @@map("appointments")
}

model Message {
  id              String    @id @default(uuid())
  userId          String
  clientId        String?
  transactionId   String?
  messageType     String
  direction       String
  subject         String?
  body            String
  status          String    @default("sent")
  openedAt        DateTime?
  createdAt       DateTime  @default(now())
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  client          Client?   @relation(fields: [clientId], references: [id])
  transaction     Transaction? @relation(fields: [transactionId], references: [id])
  @@map("messages")
}

model MessageTemplate {
  id              String    @id @default(uuid())
  userId          String
  name            String
  category        String
  subject         String?
  body            String
  variables       Json?
  usageCount      Int       @default(0)
  createdAt       DateTime  @default(now())
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@map("message_templates")
}

model ClientTimeline {
  id              String    @id @default(uuid())
  clientId        String
  eventType       String
  eventDate       DateTime  @default(now())
  summary         String
  details         Json?
  createdBy       String
  client          Client    @relation(fields: [clientId], references: [id], onDelete: Cascade)
  @@map("client_timeline")
}

model TransactionTimeline {
  id              String    @id @default(uuid())
  transactionId   String
  eventType       String
  eventDate       DateTime  @default(now())
  summary         String
  details         Json?
  createdBy       String
  transaction     Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  @@map("transaction_timeline")
}
EOF

      - name: Commit and push scaffold
        env:
          GIT_BRANCH: main
        run: |
          # Add and commit if there are changes
          git add -A
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: bootstrap scaffold (monorepo: apps/api, apps/web, prisma, ci)"
            # Push back to main
            git push origin HEAD:$GIT_BRANCH
          fi

      - name: Show created files
        run: |
          echo "Top-level files:"
          ls -la | sed -n '1,200p'
          echo "apps/api files:"
          ls -la apps/api | sed -n '1,200p' || true
          echo "apps/web files:"
          ls -la apps/web | sed -n '1,200p' || true

      - name: Finish
        run: echo "Bootstrap job completed. Inspect the repository for the new scaffold files."
