name: Bootstrap scaffold
on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  bootstrap:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create scaffold files via github-script
        uses: actions/github-script@v6
        with:
          script: |
            const files = {
              "README.md": `# Real Estate Platform

Structure:
- apps/web: Next.js (frontend placeholder)
- apps/api: Express + TypeScript + Prisma (backend)
- packages/shared: shared types/utilities

`,
              ".gitignore": `node_modules
.env
.env.local
/dist
/.next
/apps/api/node_modules
/apps/web/node_modules
/packages/*/node_modules
.DS_Store
`,
              ".env.example": `# Frontend
NEXT_PUBLIC_API_URL=http://localhost:4000/api/v1
NEXT_PUBLIC_AUTH0_DOMAIN=your-domain.auth0.com
NEXT_PUBLIC_AUTH0_CLIENT_ID=your-client-id
NEXT_PUBLIC_AUTH0_AUDIENCE=https://your-api.com

# Backend
PORT=4000
NODE_ENV=development
DATABASE_URL=postgresql://user:password@localhost:5432/realestate_db
JWT_SECRET=your-super-secret-key-change-in-production
JWT_EXPIRES_IN=15m
REFRESH_TOKEN_EXPIRES_IN=7d

# AWS S3
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
AWS_S3_BUCKET=your-bucket-name
AWS_REGION=us-east-1

# Providers (placeholders)
SENDGRID_API_KEY=your-sendgrid-key
TWILIO_API_KEY=your-twilio-key
DOCUSIGN_CLIENT_ID=your-docusign-client-id
DOCUSIGN_CLIENT_SECRET=your-docusign-client-secret
`,
              ".github/workflows/ci.yml": `name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Install backend deps
        run: |
          cd apps/api
          npm ci || true
      - name: Install frontend deps
        run: |
          cd apps/web
          npm ci || true
      - name: Lint
        run: echo "No linter configured yet"
      - name: Run tests
        run: echo "No tests configured yet"
`,
              "apps/api/package.json": `{
  "name": "real-estate-api",
  "version": "0.1.0",
  "private": true,
  "main": "dist/index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc -p .",
    "start": "node dist/index.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.400.0",
    "@aws-sdk/s3-request-presigner": "^3.400.0",
    "@prisma/client": "^5.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.0",
    "express": "^4.18.2",
    "helmet": "^6.0.1",
    "jsonwebtoken": "^9.0.0",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "prisma": "^5.0.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.17",
    "@types/node": "^20.0.0",
    "ts-node": "^10.9.1",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.0.0"
  }
}
`,
              "apps/api/tsconfig.json": `{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true
  },
  "include": ["src", "prisma"]
}
`,
              "apps/api/src/index.ts": `import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import dotenv from 'dotenv';
import uploadRoutes from './routes/upload.routes';
import healthRouter from './routes/health.routes';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 4000;

app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(morgan('dev'));

// Mount routes
app.use('/api/v1/health', healthRouter);
app.use('/api/v1/uploads', uploadRoutes);

app.get('/', (_req, res) => res.send('Real Estate API: hello'));

app.use((err: any, _req: any, res: any, _next: any) => {
  console.error(err);
  res.status(500).json({
    error: 'Something went wrong',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

app.listen(PORT, () => {
  console.log(\`ðŸš€ Server running on port \${PORT}\`);
});
`,
              "apps/api/src/routes/health.routes.ts": `import { Router } from 'express';
const router = Router();

router.get('/', (_req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

export default router;
`,
              "apps/api/src/middleware/auth.middleware.ts": `import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

export interface AuthRequest extends Request {
  user?: any;
}

export const authenticateToken = (req: AuthRequest, res: Response, next: NextFunction) => {
  const authHeader = req.headers.authorization;
  const token = authHeader?.split(' ')[1];
  if (!token) return res.status(401).json({ error: 'Access token required' });
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'dev-secret');
    req.user = decoded;
    next();
  } catch (err) {
    return res.status(403).json({ error: 'Invalid or expired token' });
  }
};
`,
              "apps/api/src/services/s3.service.ts": `import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import path from 'path';

const s3 = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || '',
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || ''
  }
});

export async function getPresignedUploadUrl(filename: string, contentType: string, maxAgeSeconds = 300) {
  const bucket = process.env.AWS_S3_BUCKET!;
  const key = \`uploads/\${Date.now()}-\${path.basename(filename)}\`;

  const command = new PutObjectCommand({
    Bucket: bucket,
    Key: key,
    ContentType: contentType
  });

  const url = await getSignedUrl(s3, command, { expiresIn: maxAgeSeconds });
  return { url, key };
}
`,
              "apps/api/src/routes/upload.routes.ts": `import { Router } from 'express';
import { getPresignedUploadUrl } from '../services/s3.service';
const router = Router();

/**
 * POST /api/v1/uploads/presign
 * Body: { filename, contentType }
 * Returns: { url, key } - client PUTs file to url (no auth example here; add authenticateToken middleware)
 */
router.post('/presign', async (req, res, next) => {
  try {
    const { filename, contentType } = req.body;
    if (!filename || !contentType) {
      return res.status(400).json({ error: 'filename and contentType required' });
    }

    const { url, key } = await getPresignedUploadUrl(filename, contentType);
    res.json({ url, key });
  } catch (err) {
    next(err);
  }
});

export default router;
`,
              "apps/api/prisma/seed.ts": `import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();

async function main() {
  // Create a sample user (passwords are not stored here; use Auth0 for auth in production)
  const user = await prisma.user.upsert({
    where: { email: 'admin@example.com' },
    update: {},
    create: {
      email: 'admin@example.com',
      firstName: 'Admin',
      lastName: 'User',
      role: 'admin'
    }
  });

  console.log('Seeded user:', user.email);
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
`,
              "apps/api/prisma/schema.prisma": `generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/* full schema omitted in workflow for brevity - you can add the complete schema locally or I can provide it */
`,
              "apps/web/package.json": `{
  "name": "real-estate-web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3000",
    "build": "next build",
    "start": "next start"
  },
  "dependencies": {
    "axios": "^1.4.0",
    "next": "14.0.0",
    "react": "18.2.0",
    "react-dom": "18.2.0"
  }
}
`,
              "apps/web/src/pages/upload.tsx": `import React, { useState } from 'react';
import axios from 'axios';

export default function UploadPage() {
  const [file, setFile] = useState<File | null>(null);
  const [status, setStatus] = useState<string | null>(null);

  async function handleUpload() {
    if (!file) return setStatus('Select a file first');
    setStatus('Requesting presigned URL...');
    try {
      const resp = await axios.post(\`\${process.env.NEXT_PUBLIC_API_URL}/uploads/presign\`, {
        filename: file.name,
        contentType: file.type || 'application/octet-stream'
      });
      const { url } = resp.data;
      setStatus('Uploading to S3...');
      await axios.put(url, file, {
        headers: { 'Content-Type': file.type }
      });
      setStatus('Upload complete');
    } catch (err: any) {
      console.error(err);
      setStatus('Upload failed: ' + (err.message || JSON.stringify(err)));
    }
  }

  return (
    <div style={{ padding: 20 }}>
      <h2>File Upload (presigned PUT)</h2>
      <input onChange={(e) => setFile(e.target.files?.[0] ?? null)} type="file" />
      <div style={{ marginTop: 10 }}>
        <button onClick={handleUpload}>Upload</button>
      </div>
      {status && <p>{status}</p>}
    </div>
  );
}
`,
              "packages/shared/package.json": `{
  "name": "@real-estate/shared",
  "version": "0.1.0",
  "private": true,
  "main": "index.js"
}
`
            };

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const committer = { name: "github-actions[bot]", email: "41898282+github-actions[bot]@users.noreply.github.com" };
            const author = committer;

            for (const path of Object.keys(files)) {
              const content = Buffer.from(files[path], "utf8").toString("base64");
              try {
                const { data } = await github.rest.repos.getContent({ owner, repo, path });
                await github.rest.repos.createOrUpdateFileContents({
                  owner,
                  repo,
                  path,
                  message: `chore: add ${path} (bootstrap)`,
                  content,
                  sha: data.sha,
                  committer,
                  author
                });
                core.info(`Updated ${path}`);
              } catch (err) {
                if (err.status === 404) {
                  await github.rest.repos.createOrUpdateFileContents({
                    owner,
                    repo,
                    path,
                    message: `chore: add ${path} (bootstrap)`,
                    content,
                    committer,
                    author
                  });
                  core.info(`Created ${path}`);
                } else {
                  throw err;
                }
              }
            }
      - name: List top-level files
        run: ls -la
